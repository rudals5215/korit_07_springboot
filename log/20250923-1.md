좋습니다 👍 지금까지 정리해주신 내용을 바탕으로 기술 블로그 글로 옮기면, 학습 흐름(프로젝트 생성 → 엔티티 개념 → 관계 설정 → DB 전환 → REST API → Spring Data REST → Postman 실습 → Query 확장)까지 자연스럽게 연결할 수 있습니다.

아래는 **벨로그에 올리기 좋은 기술 블로그 정리본**입니다.

---

# Spring Boot로 RESTful API 만들기 (Car Database 예제)

## 1. Spring Boot 프로젝트 생성

[Spring Initializr](https://start.spring.io)에서 프로젝트를 생성합니다.

* **프로젝트 설정**

  * Gradle - Groovy
  * Java
  * Spring Boot 3.5.6
  * Artifact : `com.example.cardatabase`
  * Packaging : Jar
  * Java : 17

* **추가 Dependencies**

  * Spring Web
  * Spring Boot DevTools
  * Lombok
  * Spring Data JPA

---

## 2. Spring Boot와 JPA, Entity 개념

* **Entity** : DB의 테이블과 매핑되는 클래스

  * 클래스 = 테이블
  * 필드 = 컬럼
* JPA는 Entity를 통해 DB와 연결되며, H2 같은 in-memory DB 혹은 MariaDB 같은 외부 DB와도 쉽게 연동됩니다.
* Entity는 반드시 **기본 생성자**가 필요합니다.
* `id` 값은 `@GeneratedValue(strategy = GenerationType.AUTO)`로 설정하여 DB에서 자동으로 고유 값이 생성됩니다.

### Lombok 적용 전

```java
@Entity
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;
    private String firstName, lastName;

    public Owner() {}
    public Owner(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    // getter / setter 작성
}
```

### Lombok 적용 후

```java
@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName;
    private final String lastName;
}
```

* `@NoArgsConstructor(force = true)` : `final` 필드가 있어도 기본 생성자를 강제로 생성
* `@RequiredArgsConstructor` : `final` 필드에 대한 생성자 자동 생성

---

## 3. 테이블 간의 관계 (1\:N)

* **Owner (1) ↔ Car (N)**
  한 소유자는 여러 대의 자동차를 가질 수 있음.

### Car.java

```java
@Entity
@Data
@NoArgsConstructor
public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner")
    private Owner owner;
}
```

### Owner.java

```java
@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private String firstName;
    @NonNull
    private String lastName;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}
```

* `@OneToMany(mappedBy = "owner")` : Car 테이블의 `owner` 필드와 매핑
* `cascade = CascadeType.ALL` : Owner 삭제 시 관련된 Car도 같이 삭제
* `FetchType.LAZY` : 필요한 시점에만 데이터를 가져옴

---

## 4. H2 → MariaDB 전환

### build.gradle

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    // runtimeOnly 'com.h2database:h2'
    runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
}
```

### application.properties

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:mariadb://localhost:3310/cardb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop
```

* **ddl-auto 옵션**

  * `create-drop` : 실행 시 생성, 종료 시 삭제 (개발 환경 적합)
  * `update` : 스키마 변경 시 자동 반영
  * `none` : 아무 작업 안 함

---

## 5. RESTful API 기본

* REST = **Representational State Transfer**
* 특징

  * 상태 비저장, 클라이언트-서버 독립, 캐시 가능, 일관된 인터페이스

### Controller 생성

```java
@RestController
public class CarController {
    private final CarRepository carRepository;
    public CarController(CarRepository carRepository) {
        this.carRepository = carRepository;
    }

    @GetMapping("/cars")
    public Iterable<Car> getCars(){
        return carRepository.findAll();
    }
}
```

---

## 6. JSON 직렬화 문제 해결

엔티티 간 양방향 참조 시 무한 반복 발생 → `@JsonIgnoreProperties`, `@JsonIgnore`로 해결

```java
@Entity
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Owner {
    @JsonIgnore
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}
```

---

## 7. Spring Data REST 적용

* `CarRepository`, `OwnerRepository` 자동으로 REST API 생성
* 엔드포인트 : `/api/cars`, `/api/owners`

```java
@RepositoryRestResource(path="vehicles")
public interface CarRepository extends JpaRepository<Car, Long>{}
```

→ 엔드포인트를 `/api/vehicles`로 변경 가능

### HAL 포맷 응답 예시

```json
{
  "_links": {
    "cars": {"href": "http://localhost:8080/api/cars{?page,size,sort}", "templated": true},
    "owners": {"href": "http://localhost:8080/api/owners{?page,size,sort}", "templated": true}
  }
}
```

---

## 8. Postman 실습

* **GET** : `/api/cars` → 전체 목록 조회
* **POST** : `/api/cars` → 새 자동차 추가
* **PATCH** : `/api/cars/6` → 일부 수정
* **PUT** : `/api/cars/6` → 전체 수정
* **DELETE** : `/api/cars/6` → 삭제

Owner 연결 시 `Content-Type: text/uri-list` 지정 후 PUT 요청

---

## 9. Query 메서드 확장

```java
@RepositoryRestResource
public interface CarRepository extends JpaRepository<Car, Long> {
    List<Car> findByBrand(@Param("brand") String brand);
    List<Car> findByColor(@Param("color") String color);
}
```

* `/api/cars/search/findByBrand?brand=Kia`
* `/api/cars/search/findByColor?color=White`

---

## 마무리

이번 프로젝트에서 다룬 흐름

1. Spring Boot 프로젝트 생성
2. Entity 개념과 Lombok 적용
3. Owner ↔ Car 관계 매핑
4. H2 → MariaDB 이식
5. REST API 및 직렬화 문제 해결
6. Spring Data REST 자동 엔드포인트
7. Postman을 활용한 CRUD 테스트
8. Repository에 Query 메서드 확장
