````markdown
# Spring Boot 백엔드 보호 (JJWT 0.13.0 + Record + SecurityFilterChain) — Car Database 예제

> **학습 흐름**  
> 프로젝트 생성 → OpenAPI 문서화 → Bean/@Bean → Spring Security(DB 사용자 연동) → JJWT 0.13.0 적용 → 커스텀 `/login` → JWT 필터 → 예외 처리 → CORS → Role 기반 인가 → Postman 실습

---

## 0) 빌드 설정 업데이트 (JJWT 0.13.0)

`build.gradle`  
```gradle
// jjwt 관련 설정
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
````

> **메모**
>
> * 0.13.0에서도 HMAC 키(`Keys.secretKeyFor(SignatureAlgorithm.HS256)`)를 사용하면 `builder.signWith(key)`가 동작합니다.
> * 운영에선 키를 환경변수/Secret Manager로 분리하세요.

---

## 1) JWT 발급 서비스 (JwtService)

```java
@Component
public class JwtService {
    // 1일 (밀리 초). 운영은 더 짧게/리프레시 전략 권장
    static final long EXPIRATIONTIME = 86400000;
    static final String PREFIX = "Bearer";

    // 예시: HMAC 서명 키
    static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    // 서명이 이루어진 JWT 토큰을 생성
    public String getToken(String username) {
        String token = Jwts.builder()
                .setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))
                .signWith(key)          // HS256 비밀키로 서명
                .compact();
        return token;
    }

    // Authorization 헤더에서 토큰을 꺼내 사용자(subject) 반환
    public String getAuthUser(HttpServletRequest request){
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (token != null) {
            String user = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token.replace(PREFIX,""))
                    .getBody()
                    .getSubject();
            if (user != null){
                return user;
            }
        }
        return null;
    }
}
```

---

## 2) 자격 증명 Record (Java 16+)

```java
package com.example.cardatabase.domain;

// 불변 DTO(보일러플레이트 제거)
public record AccountCredentials(String username, String password) {}
```

> Record 특징
>
> * 모든 필드 `private final` (불변)
> * 생성자/접근자/equals/hashCode/toString 자동 생성
> * 접근자는 `obj.username()` 처럼 **필드명()** 으로 호출

---

## 3) Java Optional 핵심 사용 패턴

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    Optional<AppUser> user = userRepository.findByUsername(username);

    if (user.isPresent()) {
        AppUser currentUser = user.get();
        return User.withUsername(username)
                .password(currentUser.getPassword())
                .roles(currentUser.getRole())
                .build();
    } else {
        throw new UsernameNotFoundException("User not found.");
    }
}
```

> * `Optional.ofNullable(...)`, `orElse`, `ifPresent`, `orElseThrow` 등으로 NPE 방지
> * **의도가 드러나는 API**: “값 없을 수 있음”을 호출자에게 강제 인지시킴

---

## 4) 로그인 컨트롤러 (`/login`, POST)

```java
package com.example.cardatabase.web;

import com.example.cardatabase.domain.AccountCredentials;
import com.example.cardatabase.service.JwtService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;

    public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
        this.jwtService = jwtService;
        this.authenticationManager = authenticationManager;
    }

    @PostMapping("/login")
    public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
        UsernamePasswordAuthenticationToken creds =
                new UsernamePasswordAuthenticationToken(credentials.username(), credentials.password());

        Authentication auth = authenticationManager.authenticate(creds);

        String jwts = jwtService.getToken(auth.getName());

        return ResponseEntity
                .ok()
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + jwts)
                .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "Authorization")
                .build();
    }
}
```

### `@RequestBody` 요약

* 요청 본문(JSON 등) → Java 객체 자동 바인딩
* `HttpMessageConverter`(Jackson)가 역직렬화 담당
* **POST/PUT/PATCH**에 주로 사용

---

## 5) SecurityConfig 필수 Bean & 필터 체인

### 5-1) AuthenticationManager Bean

```java
@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
    return authConfig.getAuthenticationManager();
}
```

### 5-2) JWT 인증 필터

```java
package com.example.cardatabase;

import com.example.cardatabase.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {
    private final JwtService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (jws != null) {
            String user = jwtService.getAuthUser(request);
            if (user != null) {
                Authentication authentication =
                        new UsernamePasswordAuthenticationToken(user, null, Collections.emptyList());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

### 5-3) Unauthorized 진입점(예외 처리)

```java
package com.example.cardatabase;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.io.PrintWriter;

public class AuthEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        PrintWriter writer = response.getWriter();
        writer.println("Error : " + authException.getMessage());
    }
}
```

### 5-4) SecurityFilterChain 설정 (JWT/무상태/CORS/권한)

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
                                       JwtService jwtService) throws Exception {
    AuthenticationFilter authenticationFilter = new AuthenticationFilter(jwtService);

    http
        // REST: 세션 비활성 + CSRF 비활성
        .csrf(csrf -> csrf.disable())
        .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

        // CORS (필요 시 커스터마이즈)
        .cors(Customizer.withDefaults())

        // 예외 처리: 인증 실패 → 401 JSON 메시지
        .exceptionHandling(ex -> ex.authenticationEntryPoint(new AuthEntryPoint()))

        // 권한 규칙
        .authorizeHttpRequests(auth -> auth
            .requestMatchers(HttpMethod.POST, "/login").permitAll()
            .requestMatchers(HttpMethod.GET, "/swagger-ui.html", "/swagger-ui/**", "/api-docs/**").permitAll()
            .requestMatchers(HttpMethod.GET, "/api/cars/**").hasAnyRole("USER","ADMIN")
            .requestMatchers(HttpMethod.POST, "/api/cars/**").hasRole("ADMIN")
            .anyRequest().authenticated()
        )

        // JWT 인증 필터: UsernamePasswordAuthenticationFilter 전에
        .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);

    return http.build();
}
```

> **Role 네이밍 주의**
>
> * Spring Security에서 `hasRole("ADMIN")` → 내부적으로 `ROLE_ADMIN`과 매칭
> * DB `AppUser.role` 값은 `ADMIN` / `USER` 로 저장하면 됩니다.

---

## 6) CORS 설정(선택: 프런트 분리 시)

간단 기본값(위 `cors(Customizer.withDefaults())`)으로 충분하지 않을 때:

```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000")); // 프런트 주소
    config.setAllowedMethods(List.of("GET","POST","PUT","PATCH","DELETE","OPTIONS"));
    config.setAllowedHeaders(List.of("*"));
    config.setExposedHeaders(List.of("Authorization")); // 클라이언트에서 읽을 헤더
    config.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return source;
}
```

---

## 7) `@PathVariable` 요약 (경로 변수 바인딩)

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
  @GetMapping("/{userId}")
  public ResponseEntity<User> getUserById(@PathVariable Long userId) {
    // ...
    return ResponseEntity.ok(user);
  }

  @GetMapping("/{userId}/orders/{orderId}")
  public ResponseEntity<Order> getUserOrder(@PathVariable Long userId, @PathVariable Long orderId) {
    // ...
    return ResponseEntity.ok(order);
  }
}
```

* REST 식별자에 적합 / 타입 자동 변환 / 가독성↑

---

## 8) Postman 시나리오 (JWT 인증)

1. **로그인 (토큰 발급)**

* **POST** `http://localhost:8080/login`
* Headers: `Content-Type: application/json`
* Body(JSON):

```json
{
  "username": "user",
  "password": "password"
}
```

* **성공**: 응답 헤더 `Authorization: Bearer <JWT>`

2. **보호 리소스 접근**

* **GET** `http://localhost:8080/api/cars`
* Headers: `Authorization: Bearer <JWT>`
* 권한에 따라 200/403, 토큰 없으면 401

> **자주 겪는 이슈**
>
> * `Bearer` 뒤 공백 빠짐 → 인증 실패
> * 코드 수정 후 이전 요청 재사용 → Postman 새 요청으로 테스트
> * DB의 `role` 값과 `hasRole` 불일치 → `USER/ADMIN`로 저장 확인
> * `@RepositoryRestResource(exported = false)`로 민감 리포지토리 노출 차단

---

## 9) 보너스: OpenAPI 3 (Swagger UI)

의존성:

```gradle
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'
```

설정:

```java
@Configuration
public class OpenApiConfig {
  @Bean
  public OpenAPI carDatabaseOpenApi(){
    return new OpenAPI()
      .info(new Info().title("Car REST API").description("My car Stock").version("1.0"));
  }
}
```

`application.properties`:

```properties
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
```

접속: `http://localhost:8080/swagger-ui.html`

---

## 10) 제출/리뷰 체크리스트

* [ ] JJWT 0.13.0 의존성 반영 및 서명 키 분리
* [ ] `AccountCredentials`를 **Record**로 생성
* [ ] `/login` 컨트롤러에서 **토큰 발급 + Authorization 헤더** 반환
* [ ] `AuthenticationManager` Bean 등록
* [ ] **JWT 인증 필터**(OncePerRequestFilter) 적용
* [ ] **예외 처리**: AuthEntryPoint → 401 JSON 메시지
* [ ] **CORS 노출 헤더**: `Authorization`
* [ ] **Role 기반 인가** 규칙 점검 (USER/ADMIN)
* [ ] Postman: 로그인 → 토큰으로 보호 API 접근

---

## 11) 트러블슈팅 Quick Tips

* **401 Unauthorized**: 토큰 없음/형식 오류/Bearer 공백 누락
* **403 Forbidden**: 권한 부족(ROLE 매칭 점검)
* **415 Unsupported Media Type**: `Content-Type: application/json` 누락
* **로그인 403**: 기본 Security 로그인으로 빠졌는지 확인(커스텀 `/login` 허용 규칙, `AuthenticationManager` 설정)
* **Swagger 404**: `springdoc.swagger-ui.path` 경로 재확인

---

## 12) 다음 단계

* Refresh Token/만료 갱신
* 사용자-권한 다대다 매핑 & 메소드 보안 `@PreAuthorize`
* JWT 클레임에 role 포함, 권한 부여 자동화
* 통합/단위 테스트(MockMvc)로 인증 흐름 검증

```

**바로 README/Velog에 붙여넣어도 레이아웃이 깨지지 않는** 깃허브 스타일 마크다운으로 정리했습니다.  
필요하시면 위 글을 시리즈(1편: OpenAPI/기초, 2편: Security/JWT)로 나눈 버전도 만들어 드릴게요.
```
