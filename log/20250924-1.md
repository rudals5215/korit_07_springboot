좋습니다 👍
지금까지 다룬 **OpenAPI → Bean 개념 → Spring Security(DB 연동) → JWT 기초 → Postman 인증 실습** 흐름을,
저번에 보여주신 *Car Database 기술 블로그 글* 스타일로 정리해드릴게요.

---

# Spring Boot에서 백엔드 보호하기 (OpenAPI + Spring Security + JWT)

## 1. REST API 문서화 (OpenAPI 3)

### 1) 의존성 추가

```gradle
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2'
```

### 2) 설정 클래스

```java
@Configuration
public class OpenApiConfig {
    
  @Bean
  public OpenAPI carDatabaseOpenApi(){
    return new OpenAPI()
      .info(new Info()
              .title("Car REST API")
              .description("My car Stock")
              .version("1.0"));
  }
}
```

### 3) application.properties

```properties
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
```

→ 접속 : `http://localhost:8080/swagger-ui.html`
자동으로 REST 엔드포인트를 확인 가능.

---

## 2. Bean과 @Bean 개념

* **Bean** : 스프링 IoC 컨테이너가 관리하는 객체 (싱글톤)
* **@Bean** : 메서드 반환 객체를 컨테이너에 등록

### @Bean 사용 전

```java
public class MyController {
  private MyService myService = new MyService();
}
```

→ 강한 결합, 테스트 어려움.

### @Bean 사용 후

```java
@Configuration
public class AppConfig {
  @Bean
  public MyService myService() {
    return new MyService();
  }
}
```

```java
@Controller
public class MyController {
  private final MyService myService;
  public MyController(MyService myService) {
    this.myService = myService;
  }
}
```

→ IoC 컨테이너가 객체를 생성 & 주입 → 결합도 ↓, 테스트 ↑.

---

## 3. Spring Security 기본 도입

### 1) 의존성 추가

```gradle
implementation 'org.springframework.boot:spring-boot-starter-security'
```

### 2) 인메모리 사용자 예시

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public InMemoryUserDetailsManager userDetailsService(){
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();
        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

→ 실행 시 `/login` 자동 제공, Basic Auth로 인증 확인 가능.

---

## 4. DB 사용자 연동하기

### 1) AppUser 엔티티

```java
@Entity
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
@Getter
@Setter
public class AppUser {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column(nullable = false, unique = true)
    private final String username;

    @Column(nullable = false)
    private final String password;

    @Column(nullable = false)
    private final String role;
}
```

### 2) AppUserRepository

```java
@RepositoryRestResource(exported = false)
public interface AppUserRepository extends JpaRepository<AppUser, Long> {
    Optional<AppUser> findByUsername(String username);
}
```

→ `exported = false`로 자동 REST 노출 차단.

### 3) UserDetailsService 구현

```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    private final AppUserRepository userRepository;

    public UserDetailsServiceImpl(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = userRepository.findByUsername(username);

        if (user.isPresent()) {
            AppUser currentUser = user.get();
            return User.withUsername(username)
                       .password(currentUser.getPassword())
                       .roles(currentUser.getRole())
                       .build();
        } else {
            throw new UsernameNotFoundException("User not found.");
        }
    }
}
```

### 4) SecurityConfig (DB 연동)

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    public void configGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService)
            .passwordEncoder(new BCryptPasswordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

→ DB 사용자 인증이 가능해짐.

---

## 5. Postman 인증 테스트

1. `GET http://localhost:8080/api/cars` 요청

   * 인증 없음 → `401 Unauthorized`
2. Basic Auth 선택 → DB 사용자 계정 입력

   * 인증 성공 → `200 OK`

---

## 6. JWT 도입 준비

### 1) 의존성 추가

```gradle
implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
```

### 2) JwtService

```java
@Component
public class JwtService {
    static final long EXPIRATIONTIME = 86400000; // 1일
    static final String PREFIX = "Bearer";
    static final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    public String getToken(String username) {
        return Jwts.builder()
                   .setSubject(username)
                   .setExpiration(new Date(System.currentTimeMillis() + EXPIRATIONTIME))
                   .signWith(key)
                   .compact();
    }

    public String getAuthUser(HttpServletRequest request){
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (token != null) {
            return Jwts.parserBuilder()
                       .setSigningKey(key)
                       .build()
                       .parseClaimsJws(token.replace(PREFIX, ""))
                       .getBody()
                       .getSubject();
        }
        return null;
    }
}
```

→ 토큰 발급(`getToken`) + 사용자 검증(`getAuthUser`) 지원.

---

## 7. 마무리

이번 학습 흐름 정리:

1. OpenAPI 3로 REST API 문서화
2. Bean / @Bean 개념 정리
3. Spring Security 인메모리 사용자 테스트
4. DB 사용자 연동 및 Repository 보안 처리
5. Postman으로 인증 테스트
6. JWT 도입 준비 (토큰 발급 & 검증 로직)

다음 단계에서는 **JWT 로그인 엔드포인트 구현 → 필터 적용 → Role 기반 인가**까지 확장할 예정입니다. 🚀

---

👉 이렇게 하면 벨로그/깃허브 블로그에 그대로 올려도 **흐름 + 코드 + 설명**이 자연스럽게 이어지는 글이 됩니다.

원하시면 제가 이 글을 **1편(REST + 문서화)**, **2편(Security + JWT)** 시리즈로 나눠드릴까요?
