````markdown
# Spring Boot — CORS Filter 추가 & Role 기반 보호 & 테스트 정리 (Car Database 예제)

> **학습 흐름**  
> JJWT 0.13.0 적용 → 커스텀 `/login` → **CORS Filter 추가** → **Role 기반 인가** → **테스트 전략**  
> 아래 문서는 **깃허브/벨로그에 그대로 붙여넣어도 깨지지 않는** 마크다운 형식입니다.  
> (코드 블록은 요청하신 그대로 유지)

---

## 1) CORS Filter 추가하기

- **CORS(Cross-Origin Resource Sharing)**: 브라우저가 **교차 출처** 요청을 허용/거부할지 헤더로 결정하는 표준 메커니즘  
- 프런트엔드(다른 출처) → 백엔드로 요청 시, **CORS 필터**가 요청을 가로채 허용 헤더를 추가/검증  
- 여기서는 Spring Security에 **`CorsConfigurationSource`** 를 등록하고, `SecurityFilterChain`에 **`.cors(...)`** 를 활성화합니다.
- 현재 예제는 **모든 출처/메서드/헤더 허용**(데모용). 실제 운영에서는 **특정 Origin만 허용** 권장

### 1-1) SecurityConfig (수정 전)

```java
package com.example.cardatabase;

import com.example.cardatabase.service.UserDetailsServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private final UserDetailsServiceImpl userDetailsService;
    private final AuthenticationFilter authenticationFilter;
    private final AuthEntryPoint exceptionHandler;

    public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter, AuthEntryPoint exceptionHandler) {
        this.userDetailsService = userDetailsService;
        this.authenticationFilter = authenticationFilter;
        this.exceptionHandler = exceptionHandler;
    }


    public void configGlobal (AuthenticationManagerBuilder auth) throws Exception{
        auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager (AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf ->csrf.disable())
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers(HttpMethod.POST,"/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
}
````

### 1-2) CORS 설정 Bean 추가

```java
@Bean
  public CorsConfigurationSource corsConfigurationSource() {
      UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
      CorsConfiguration config = new CorsConfiguration();
      config.setAllowedOrigins(Arrays.asList("*"));
      config.setAllowedMethods(Arrays.asList("*"));
      config.setAllowedHeaders(Arrays.asList("*"));

      config.setAllowCredentials(false);
      config.applyPermitDefaultValues();

      source.registerCorsConfiguration("/**", config);
      return source;
  }
```

> **특정 Origin만 허용하려면?**
> `config.setAllowedOrigins(Arrays.asList("http://localhost:5173","http://localhost:3000"))`
> (프런트 기본 포트 5173/Vite, 3000/CRA. 혼동 시 `5173` 검색!)

### 1-3) filterChain에 CORS 활성화

```java
import static org.springframework.security.config.Customizer.withDefaults;

@Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf ->csrf.disable())
                .cors(withDefaults())       // 여기 추가 (CORS 활성화)
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests.requestMatchers(HttpMethod.POST,"/login").permitAll().anyRequest().authenticated())
                .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
        return http.build();
    }
```

> **주의**
>
> * `allowedOrigins="*"` + `allowCredentials=true` 는 브라우저 정책상 **동시에 허용 불가**입니다. 지금 예제는 `allowCredentials=false` 이므로 OK.
> * 프런트에서 `Authorization` 헤더를 읽으려면 **노출 헤더**로 `Authorization`을 추가해야 합니다(이미 로그인 응답에서 `ACCESS_CONTROL_EXPOSE_HEADERS` 설정).

---

## 2) Role-Based Protection (요청 수준)

* Spring Security는 역할(ROLE_)을 이용해 **세분화된 접근 제어**가 가능합니다.
* 일반적으로 `USER < MANAGER < ADMIN`과 같은 **계층적 권한**을 구성(기본 예시)

### 2-1) 요청 수준에서 역할 매핑 예시

> **참고:** 아래는 학습용 예시로, 예제 프로젝트에는 즉시 도입하지 않습니다.

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
  http.csrf(csrf ->csrf.disable())
          .cors(withDefaults())
          .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
          .authorizeHttpRequests(authorizeHttpRequests -> authorizeHttpRequests
              .requestMatchers("/admin/**").hasRole("ADMIN")
              .requestMatchers("/user/**").hasRole("USER")
              .anyRequest().authenticated())
          .addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class)
          .exceptionHandling(exceptionHandling -> exceptionHandling.authenticationEntryPoint(exceptionHandler));
  return http.build();
}
```

* `hasRole("ADMIN")` → 내부적으로 `ROLE_ADMIN`과 매칭
* DB의 `role` 필드는 `ADMIN`/`USER` 처럼 저장하면 됩니다.

### 2-2) 메서드 수준 보안(옵션)

* `@PreAuthorize`, `@PostAuthorize`, `@Secured` 등
* 활성화: 최상위 구성 클래스(예: `CarDatabaseApplication`)에 `@EnableMethodSecurity`
* 예시: `@PreAuthorize("hasRole('ADMIN')")`

---

## 3) 백엔드 테스트 (catdatabase_3_test)

### 3-1) 테스트 준비

* `spring-boot-starter-test` 의존성 포함 (JUnit, Mockito, AssertJ)
* 테스트에서는 **H2 인메모리 DB** 사용 권장:

```gradle
testRuntimeOnly 'com.h2database:h2'
```

### 3-2) 테스트 유형 요약

1. **단위(Unit)**: 함수/클래스 단위. Mocking 적극 활용
2. **통합(Integration)**: 컴포넌트 간 상호작용 검증
3. **기능/시나리오(Functional)**: 요구사항 충족 여부
4. **회귀(Regression)**: 변경이 기존 기능을 깨지지 않게
5. **웹 레이어**: `@WebMvcTest` + `MockMvc`로 컨트롤러 테스트

### 3-3) 기본 테스트 클래스 골격

```java
@SpringBootTest
public class MyTestClass{

  @Test
  public void testMethod() {
    // 테스트 케이스 로직
  }
}
```

* `@SpringBootTest`: 전체 컨텍스트 로드
* `assertThat(...)` (AssertJ)로 가독성 좋은 검증 작성

### 3-4) Repository 통합 테스트 예시

```java
package com.example.cardatabase;

import com.example.cardatabase.domain.OwnerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

@DataJpaTest
class OwnerRepositoryTest {
    @Autowired
    private OwnerRepository ownerRepository;
}
```

> `@DataJpaTest`: JPA 슬라이스 테스트, H2/스프링 데이터 자동 구성, SQL 로깅 강화

#### 삭제 테스트 스니펫

```java
@Test
@DisplayName("삭제 테스트 : ")
void deleteOwners() {
  ownerRepository.save(new Owner("팔백","박"));
  ownerRepository.deleteAll();
  assertThat(ownerRepository.count()).isEqualTo(0);
}
```

### 3-5) MockMvc로 로그인 인증 테스트

```java
package com.example.cardatabase;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
public class CarRestTest {
    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("자격증명인증테스트")
    public void testAuthentication() throws Exception{
        this.mockMvc.perform(post("/login")
                .content("{\"username\" : \"admin\", \"password\" : \"admin\"}")
                .header(HttpHeaders.CONTENT_TYPE, "application/json"))
                .andDo(print()).andExpect(status().isOk());
    }
}
```

### 3-6) CarRepository 저장 테스트

```java
@DataJpaTest
public class CarRepositoryTest {
    @Autowired
    private CarRepository carRepository;
    @Autowired
    private OwnerRepository ownerRepository;

    @Test
    @DisplayName("차량 저장 메서드 테스트")
    void saveCar() {
        Owner owner = new Owner("Gemini", "GPT");
        ownerRepository.save(owner);

        Car car = new Car("Ford","Mustang","Red","ABCEDF",2021,567890,owner);
        carRepository.save(car);

        assertThat(carRepository.findById(car.getId())).isPresent();
        assertThat(carRepository.findById(car.getId()).get().getBrand()).isEqualTo("Ford");
    }
}
```

### 3-7) 과제형 예시 문제들 (발췌)

**1) 차량 삭제 테스트**

```java
@Test
@DisplayName("차량 삭제 메서드 테스트")
void deleteCar() {
    Owner owner = new Owner("이십","조");
    ownerRepository.save(owner);
    Car car = new Car("Kia","EV5","White","45HA7894",2024,500000,owner);
    carRepository.save(car);

    carRepository.deleteAll();

    assertThat(carRepository.findById(car.getId())).isNotPresent();
//  assertThat(carRepository.count()).isEqualTo(0);
}
```

**2) 특정 브랜드 조회**

```java
@Test
@DisplayName("특정 브랜드 차량 조회 메서드")
void findByBrandShouldReturnCar() {
    Owner owner = new Owner("이십","조");
    carRepository.save(new Car("Kia", "Seltos", "Chacol", "370SU5690", 2020, 30000000,owner));
    carRepository.save(new Car("Kia","EV5","White","45HA7894",2024,500000,owner));
    carRepository.save(new Car("Ford","Mustang","Red","ABCEDF",2021,567890,owner));

    List<Car> Kias = carRepository.findByBrand("Kia");

    assertThat(Kias.get(1).getBrand()).isEqualTo("Kia");
    assertThat(Kias.size()).isEqualTo(2);
}
```

**3) 사용자명 조회**

```java
@DataJpaTest
public class AppRepositoryTest {
    @Autowired
    private AppUserRepository userRepository;

    @Test
    @DisplayName("사용자 이름을 통한 조회")
    void findByUsernameReturnUser() {
        userRepository.save(new AppUser("user4","user","USER"));
        Optional<AppUser> foundUser = userRepository.findByUsername("user4");
        assertThat(foundUser).isPresent();
        assertThat(foundUser.get().getRole()).isEqualTo("USER");
    }
}
```

**4) 컨트롤러 GET 200 OK**

```java
@WebMvcTest(CarController.class)
public class CarControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private CarRepository carRepository;

    @Test
    @DisplayName("GET /cars 요청 테스트 검증")
    void testGetCars() throws Exception{
        this.mockMvc.perform(get("/cars")).andExpect(status().isOk());
    }
}
```

---

## 4) Postman 실습 메모

1. **로그인**

* POST `/login`
* Headers: `Content-Type: application/json`
* Body:

```json
{"username":"admin","password":"admin"}
```

* 성공 시 응답 헤더: `Authorization: Bearer <JWT>`
* 프런트에서 헤더 읽을 수 있도록 `ACCESS_CONTROL_EXPOSE_HEADERS: Authorization` 반환됨

2. **보호 API 접근**

* 예: GET `/api/cars`
* Headers: `Authorization: Bearer <JWT>`
* 실패 시: 401(토큰 없음/형식오류), 403(권한 부족)

> **자주 겪는 이슈**
>
> * `Bearer` 뒤 공백 누락
> * 코드 수정 후 이전 요청 재사용 → **새 요청으로 테스트**
> * DB `role` 값(`USER/ADMIN`)과 `hasRole` 불일치
> * CORS: 프런트 오리진/노출 헤더(Authorization) 확인

---

## 5) 체크리스트

* [ ] `CorsConfigurationSource` 등록 & `.cors(withDefaults())` 적용
* [ ] 필요 시 특정 Origin만 허용 (`http://localhost:5173` 등)
* [ ] Role 규칙 설계(요청/메서드 수준) 및 DB role 값 일치
* [ ] AuthEntryPoint로 **401 JSON 메시지** 반환
* [ ] Postman: 로그인 → JWT로 보호 API 접근
* [ ] 테스트: JPA 슬라이스/MockMvc/통합 테스트 분리 운영

---

## 6) 다음 단계

* Role 계층/권한 매핑(여러 권한 보유 사용자)
* Refresh Token 흐름 도입
* `@EnableMethodSecurity` + `@PreAuthorize` 세분화
* OpenAPI에 **Auth 헤더 전역 설정**(Swagger UI에서 토큰 입력)
* 테스트: 시큐리티 컨텍스트 포함 E2E 시나리오

```

원하시면 이 문서를 **프로젝트 루트의 `README.md`** 로 쓰기 좋게 소제목/목차만 더 다듬어 드릴게요.
```
